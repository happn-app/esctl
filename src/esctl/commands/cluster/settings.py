import re
from typing import Annotated, Any, Callable, Iterable, TypedDict

import typer
from rich.prompt import Confirm

from esctl.config import Config
from esctl.options import (
    OutputOption,
    Result,
)

app = typer.Typer(rich_markup_mode="rich")


def complete_settings_key(incomplete: str) -> Iterable[str]:
    setting_keys = [
        "action.auto_create_index",
        "action.destructive_requires_name",
        "action.search.pre_filter_shard_size.default",
        "action.search.shard_count.limit",
        "async_search.index_cleanup_interval",
        "bootstrap.ctrlhandler",
        "bootstrap.memory_lock",
        "cache.recycler.page.limit.heap",
        "cache.recycler.page.type",
        "cache.recycler.page.weight.bytes",
        "cache.recycler.page.weight.ints",
        "cache.recycler.page.weight.longs",
        "cache.recycler.page.weight.objects",
        "ccr.auto_follow.wait_for_metadata_timeout",
        "ccr.indices.recovery.chunk_size",
        "ccr.indices.recovery.internal_action_timeout",
        "ccr.indices.recovery.max_bytes_per_sec",
        "ccr.indices.recovery.max_concurrent_file_chunks",
        "ccr.indices.recovery.recovery_activity_timeout",
        "ccr.wait_for_metadata_timeout",
        "client.type",
        "cluster.auto_shrink_voting_configuration",
        "cluster.blocks.read_only",
        "cluster.blocks.read_only_allow_delete",
        "cluster.deprecation_indexing.enabled",
        "cluster.deprecation_indexing.x_opaque_id_used.enabled",
        "cluster.discovery_configuration_check.interval",
        "cluster.election.back_off_time",
        "cluster.election.duration",
        "cluster.election.initial_timeout",
        "cluster.election.max_timeout",
        "cluster.election.strategy",
        "cluster.fault_detection.follower_check.interval",
        "cluster.fault_detection.follower_check.retry_count",
        "cluster.fault_detection.follower_check.timeout",
        "cluster.fault_detection.leader_check.interval",
        "cluster.fault_detection.leader_check.retry_count",
        "cluster.fault_detection.leader_check.timeout",
        "cluster.follower_lag.timeout",
        "cluster.indices.close.enable",
        "cluster.indices.tombstones.size",
        "cluster.info.update.interval",
        "cluster.info.update.timeout",
        "cluster.initial_master_nodes",
        "cluster.join_validation.cache_timeout",
        "cluster.max_shards_per_node",
        "cluster.max_shards_per_node.frozen",
        "cluster.max_voting_config_exclusions",
        "cluster.name",
        "cluster.no_master_block",
        "cluster.nodes.reconnect_interval",
        "cluster.persistent_tasks.allocation.enable",
        "cluster.persistent_tasks.allocation.recheck_interval",
        "cluster.publish.info_timeout",
        "cluster.publish.timeout",
        "cluster.remote.connections_per_cluster",
        "cluster.remote.initial_connect_timeout",
        "cluster.remote.node.attr",
        "cluster.routing.allocation.allow_rebalance",
        "cluster.routing.allocation.awareness.attributes",
        "cluster.routing.allocation.balance.disk_usage",
        "cluster.routing.allocation.balance.index",
        "cluster.routing.allocation.balance.shard",
        "cluster.routing.allocation.balance.threshold",
        "cluster.routing.allocation.balance.write_load",
        "cluster.routing.allocation.cluster_concurrent_rebalance",
        "cluster.routing.allocation.disk.reroute_interval",
        "cluster.routing.allocation.disk.threshold_enabled",
        "cluster.routing.allocation.disk.watermark.enable_for_single_data_node",
        "cluster.routing.allocation.disk.watermark.flood_stage",
        "cluster.routing.allocation.disk.watermark.flood_stage.frozen",
        "cluster.routing.allocation.disk.watermark.flood_stage.frozen.max_headroom",
        "cluster.routing.allocation.disk.watermark.flood_stage.max_headroom",
        "cluster.routing.allocation.disk.watermark.high",
        "cluster.routing.allocation.disk.watermark.high.max_headroom",
        "cluster.routing.allocation.disk.watermark.low",
        "cluster.routing.allocation.disk.watermark.low.max_headroom",
        "cluster.routing.allocation.enable",
        "cluster.routing.allocation.enforce_default_tier_preference",
        "cluster.routing.allocation.node_concurrent_incoming_recoveries",
        "cluster.routing.allocation.node_concurrent_outgoing_recoveries",
        "cluster.routing.allocation.node_concurrent_recoveries",
        "cluster.routing.allocation.node_initial_primaries_recoveries",
        "cluster.routing.allocation.same_shard.host",
        "cluster.routing.allocation.total_shards_per_node",
        "cluster.routing.allocation.type",
        "cluster.routing.rebalance.enable",
        "cluster.routing.use_adaptive_replica_selection",
        "cluster.service.master_service_starvation_logging_threshold",
        "cluster.service.slow_master_task_logging_threshold",
        "cluster.service.slow_task_logging_threshold",
        "cluster.snapshot.info.max_concurrent_fetches",
        "cluster_state.document_page_size",
        "deprecation.skip_deprecated_settings",
        "discovery.cluster_formation_warning_timeout",
        "discovery.find_peers_interval",
        "discovery.initial_state_timeout",
        "discovery.probe.connect_timeout",
        "discovery.probe.handshake_timeout",
        "discovery.request_peers_timeout",
        "discovery.seed_hosts",
        "discovery.seed_providers",
        "discovery.seed_resolver.max_concurrent_resolvers",
        "discovery.seed_resolver.timeout",
        "discovery.type",
        "discovery.unconfigured_bootstrap_timeout",
        "enrich.cache_size",
        "enrich.cleanup_period",
        "enrich.coordinator_proxy.max_concurrent_requests",
        "enrich.coordinator_proxy.max_lookups_per_request",
        "enrich.coordinator_proxy.queue_capacity",
        "enrich.fetch_size",
        "enrich.max_concurrent_policy_executions",
        "enrich.max_force_merge_attempts",
        "gateway.expected_data_nodes",
        "gateway.recover_after_data_nodes",
        "gateway.recover_after_time",
        "gateway.slow_write_logging_threshold",
        "gateway.write_dangling_indices_info",
        "health.master_history.has_master_lookup_timeframe",
        "health.master_history.identity_changes_threshold",
        "health.master_history.no_master_transitions_threshold",
        "health.node.enabled",
        "health.reporting.local.monitor.interval",
        "health_node.transport_action_timeout",
        "http.bind_host",
        "http.client_stats.closed_channels.max_age",
        "http.client_stats.closed_channels.max_count",
        "http.client_stats.enabled",
        "http.compression",
        "http.compression_level",
        "http.cors.allow-credentials",
        "http.cors.allow-headers",
        "http.cors.allow-methods",
        "http.cors.allow-origin",
        "http.cors.enabled",
        "http.cors.max-age",
        "http.detailed_errors.enabled",
        "http.host",
        "http.max_chunk_size",
        "http.max_content_length",
        "http.max_header_size",
        "http.max_initial_line_length",
        "http.max_warning_header_count",
        "http.max_warning_header_size",
        "http.netty.max_composite_buffer_components",
        "http.netty.receive_predictor_size",
        "http.netty.worker_count",
        "http.pipelining.max_events",
        "http.port",
        "http.publish_host",
        "http.publish_port",
        "http.read_timeout",
        "http.reset_cookies",
        "http.tcp.keep_alive",
        "http.tcp.keep_count",
        "http.tcp.keep_idle",
        "http.tcp.keep_interval",
        "http.tcp.no_delay",
        "http.tcp.receive_buffer_size",
        "http.tcp.reuse_address",
        "http.tcp.send_buffer_size",
        "http.tracer.exclude",
        "http.tracer.include",
        "http.type",
        "http.type.default",
        "index.codec",
        "index.recovery.type",
        "index.store.fs.fs_lock",
        "index.store.preload",
        "index.store.snapshot.cache.excluded_file_types",
        "index.store.snapshot.uncached_chunk_size",
        "index.store.type",
        "indexing_pressure.memory.limit",
        "indices.analysis.hunspell.dictionary.ignore_case",
        "indices.analysis.hunspell.dictionary.lazy",
        "indices.breaker.fielddata.limit",
        "indices.breaker.fielddata.overhead",
        "indices.breaker.fielddata.type",
        "indices.breaker.request.limit",
        "indices.breaker.request.overhead",
        "indices.breaker.request.type",
        "indices.breaker.total.limit",
        "indices.breaker.total.use_real_memory",
        "indices.breaker.type",
        "indices.cache.cleanup_interval",
        "indices.fielddata.cache.size",
        "indices.id_field_data.enabled",
        "indices.lifecycle.history_index_enabled",
        "indices.lifecycle.poll_interval",
        "indices.lifecycle.rollover.only_if_has_documents",
        "indices.lifecycle.step.master_timeout",
        "indices.mapping.dynamic_timeout",
        "indices.mapping.max_in_flight_updates",
        "indices.memory.index_buffer_size",
        "indices.memory.interval",
        "indices.memory.max_index_buffer_size",
        "indices.memory.min_index_buffer_size",
        "indices.memory.shard_inactive_time",
        "indices.queries.cache.all_segments",
        "indices.queries.cache.count",
        "indices.queries.cache.size",
        "indices.query.bool.max_clause_count",
        "indices.query.bool.max_nested_depth",
        "indices.query.query_string.allowLeadingWildcard",
        "indices.query.query_string.analyze_wildcard",
        "indices.recovery.internal_action_long_timeout",
        "indices.recovery.internal_action_retry_timeout",
        "indices.recovery.internal_action_timeout",
        "indices.recovery.max_bytes_per_sec",
        "indices.recovery.max_concurrent_file_chunks",
        "indices.recovery.max_concurrent_operations",
        "indices.recovery.max_concurrent_snapshot_file_downloads",
        "indices.recovery.max_concurrent_snapshot_file_downloads_per_node",
        "indices.recovery.recovery_activity_timeout",
        "indices.recovery.retry_delay_network",
        "indices.recovery.retry_delay_state_sync",
        "indices.recovery.use_snapshots",
        "indices.replication.initial_retry_backoff_bound",
        "indices.replication.retry_timeout",
        "indices.requests.cache.expire",
        "indices.requests.cache.size",
        "indices.store.delete.shard.timeout",
        "indices.write_ack_delay_interval",
        "indices.write_ack_delay_randomness_bound",
        "ingest.geoip.cache_size",
        "ingest.geoip.downloader.enabled",
        "ingest.geoip.downloader.endpoint",
        "ingest.geoip.downloader.poll.interval",
        "ingest.grok.watchdog.interval",
        "ingest.grok.watchdog.max_execution_time",
        "ingest.user_agent.cache_size",
        "logger.level",
        "master_history.max_age",
        "monitor.fs.health.enabled",
        "monitor.fs.health.refresh_interval",
        "monitor.fs.health.slow_path_logging_threshold",
        "monitor.fs.refresh_interval",
        "monitor.jvm.gc.enabled",
        "monitor.jvm.gc.overhead.debug",
        "monitor.jvm.gc.overhead.info",
        "monitor.jvm.gc.overhead.warn",
        "monitor.jvm.gc.refresh_interval",
        "monitor.jvm.refresh_interval",
        "monitor.os.refresh_interval",
        "monitor.process.refresh_interval",
        "network.bind_host",
        "network.breaker.inflight_requests.limit",
        "network.breaker.inflight_requests.overhead",
        "network.host",
        "network.publish_host",
        "network.server",
        "network.tcp.keep_alive",
        "network.tcp.keep_count",
        "network.tcp.keep_idle",
        "network.tcp.keep_interval",
        "network.tcp.no_delay",
        "network.tcp.receive_buffer_size",
        "network.tcp.reuse_address",
        "network.tcp.send_buffer_size",
        "node.attr.k8s_node_name",
        "node.attr.xpack.installed",
        "node.bandwidth.recovery.disk.read",
        "node.bandwidth.recovery.disk.write",
        "node.bandwidth.recovery.factor.read",
        "node.bandwidth.recovery.factor.write",
        "node.bandwidth.recovery.network",
        "node.bandwidth.recovery.operator.factor",
        "node.bandwidth.recovery.operator.factor.max_overcommit",
        "node.bandwidth.recovery.operator.factor.read",
        "node.bandwidth.recovery.operator.factor.write",
        "node.enable_lucene_segment_infos_trace",
        "node.external_id",
        "node.id.seed",
        "node.name",
        "node.portsfile",
        "node.processors",
        "node.roles",
        "node.store.allow_mmap",
        "path.data",
        "path.home",
        "path.logs",
        "path.repo",
        "path.shared_data",
        "plugin.mandatory",
        "readiness.port",
        "reindex.remote.whitelist",
        "repositories.fs.chunk_size",
        "repositories.fs.location",
        "repositories.url.allowed_urls",
        "repositories.url.supported_protocols",
        "repositories.url.url",
        "resource.reload.enabled",
        "resource.reload.interval.high",
        "resource.reload.interval.low",
        "resource.reload.interval.medium",
        "rest.action.multi.allow_explicit_index",
        "runtime_fields.grok.watchdog.interval",
        "runtime_fields.grok.watchdog.max_execution_time",
        "script.allowed_contexts",
        "script.allowed_types",
        "script.cache.expire",
        "script.cache.max_size",
        "script.disable_max_compilations_rate",
        "script.max_compilations_rate",
        "script.max_size_in_bytes",
        "script.painless.regex.enabled",
        "script.painless.regex.limit-factor",
        "search.aggs.rewrite_to_filter_by_filter",
        "search.allow_expensive_queries",
        "search.check_ccs_compatibility",
        "search.default_allow_partial_results",
        "search.default_keep_alive",
        "search.default_search_timeout",
        "search.highlight.term_vector_multi_value",
        "search.keep_alive_interval",
        "search.low_level_cancellation",
        "search.max_async_search_response_size",
        "search.max_buckets",
        "search.max_keep_alive",
        "search.max_open_scroll_context",
        "searchable_snapshots.blob_cache.periodic_cleanup.batch_size",
        "searchable_snapshots.blob_cache.periodic_cleanup.interval",
        "searchable_snapshots.blob_cache.periodic_cleanup.pit_keep_alive",
        "searchable_snapshots.blob_cache.periodic_cleanup.retention_period",
        "security.manager.filter_bad_defaults",
        "slm.health.failed_snapshot_warn_threshold",
        "slm.history_index_enabled",
        "slm.minimum_interval",
        "slm.retention_duration",
        "slm.retention_schedule",
        "snapshot.max_concurrent_operations",
        "snapshot.refresh_repo_uuid_on_restore",
        "stack.templates.enabled",
        "thread_pool.analyze.queue_size",
        "thread_pool.analyze.size",
        "thread_pool.auto_complete.queue_size",
        "thread_pool.auto_complete.size",
        "thread_pool.azure_event_loop.core",
        "thread_pool.azure_event_loop.keep_alive",
        "thread_pool.azure_event_loop.max",
        "thread_pool.cluster_coordination.queue_size",
        "thread_pool.cluster_coordination.size",
        "thread_pool.estimated_time_interval",
        "thread_pool.estimated_time_interval.warn_threshold",
        "thread_pool.fetch_shard_started.core",
        "thread_pool.fetch_shard_started.keep_alive",
        "thread_pool.fetch_shard_started.max",
        "thread_pool.fetch_shard_store.core",
        "thread_pool.fetch_shard_store.keep_alive",
        "thread_pool.fetch_shard_store.max",
        "thread_pool.flush.core",
        "thread_pool.flush.keep_alive",
        "thread_pool.flush.max",
        "thread_pool.force_merge.queue_size",
        "thread_pool.force_merge.size",
        "thread_pool.generic.core",
        "thread_pool.generic.keep_alive",
        "thread_pool.generic.max",
        "thread_pool.get.queue_size",
        "thread_pool.get.size",
        "thread_pool.management.core",
        "thread_pool.management.keep_alive",
        "thread_pool.management.max",
        "thread_pool.refresh.core",
        "thread_pool.refresh.keep_alive",
        "thread_pool.refresh.max",
        "thread_pool.repository_azure.core",
        "thread_pool.repository_azure.keep_alive",
        "thread_pool.repository_azure.max",
        "thread_pool.scheduler.warn_threshold",
        "thread_pool.search.queue_size",
        "thread_pool.search.size",
        "thread_pool.search_coordination.queue_size",
        "thread_pool.search_coordination.size",
        "thread_pool.search_throttled.queue_size",
        "thread_pool.search_throttled.size",
        "thread_pool.snapshot.core",
        "thread_pool.snapshot.keep_alive",
        "thread_pool.snapshot.max",
        "thread_pool.snapshot_meta.core",
        "thread_pool.snapshot_meta.keep_alive",
        "thread_pool.snapshot_meta.max",
        "thread_pool.system_critical_read.queue_size",
        "thread_pool.system_critical_read.size",
        "thread_pool.system_critical_write.queue_size",
        "thread_pool.system_critical_write.size",
        "thread_pool.system_read.queue_size",
        "thread_pool.system_read.size",
        "thread_pool.system_write.queue_size",
        "thread_pool.system_write.size",
        "thread_pool.vectortile.queue_size",
        "thread_pool.vectortile.size",
        "thread_pool.warmer.core",
        "thread_pool.warmer.keep_alive",
        "thread_pool.warmer.max",
        "thread_pool.write.queue_size",
        "thread_pool.write.size",
        "time_series.poll_interval",
        "tracing.apm.enabled",
        "tracing.apm.names.exclude",
        "tracing.apm.names.include",
        "transport.bind_host",
        "transport.compress",
        "transport.compression_scheme",
        "transport.connect_timeout",
        "transport.connections_per_node.bulk",
        "transport.connections_per_node.ping",
        "transport.connections_per_node.recovery",
        "transport.connections_per_node.reg",
        "transport.connections_per_node.state",
        "transport.host",
        "transport.netty.boss_count",
        "transport.netty.receive_predictor_max",
        "transport.netty.receive_predictor_min",
        "transport.netty.receive_predictor_size",
        "transport.netty.worker_count",
        "transport.ping_schedule",
        "transport.port",
        "transport.publish_host",
        "transport.publish_port",
        "transport.rst_on_close",
        "transport.slow_operation_logging_threshold",
        "transport.tcp.keep_alive",
        "transport.tcp.keep_count",
        "transport.tcp.keep_idle",
        "transport.tcp.keep_interval",
        "transport.tcp.no_delay",
        "transport.tcp.receive_buffer_size",
        "transport.tcp.reuse_address",
        "transport.tcp.send_buffer_size",
        "transport.tracer.exclude",
        "transport.tracer.include",
        "transport.type",
        "transport.type.default",
        "write_load_forecaster.max_index_age",
        "xpack.autoscaling.memory.monitor.timeout",
        "xpack.ccr.ccr_thread_pool.queue_size",
        "xpack.ccr.ccr_thread_pool.size",
        "xpack.ccr.enabled",
        "xpack.eql.enabled",
        "xpack.graph.enabled",
        "xpack.http.connection_pool_ttl",
        "xpack.http.default_connection_timeout",
        "xpack.http.default_read_timeout",
        "xpack.http.max_response_size",
        "xpack.http.proxy.host",
        "xpack.http.proxy.port",
        "xpack.http.proxy.scheme",
        "xpack.http.tcp.keep_alive",
        "xpack.http.whitelist",
        "xpack.idp.allowed_nameid_formats",
        "xpack.idp.contact.email",
        "xpack.idp.contact.given_name",
        "xpack.idp.contact.surname",
        "xpack.idp.defaults.authn_expiry",
        "xpack.idp.defaults.nameid_format",
        "xpack.idp.enabled",
        "xpack.idp.entity_id",
        "xpack.idp.metadata.signing.keystore.alias",
        "xpack.idp.organization.display_name",
        "xpack.idp.organization.name",
        "xpack.idp.organization.url",
        "xpack.idp.privileges.application",
        "xpack.idp.privileges.cache.size",
        "xpack.idp.privileges.cache.ttl",
        "xpack.idp.signing.keystore.alias",
        "xpack.idp.slo_endpoint.post",
        "xpack.idp.slo_endpoint.redirect",
        "xpack.idp.sp.cache.size",
        "xpack.idp.sp.cache.ttl",
        "xpack.idp.sp.wildcard.path",
        "xpack.idp.sso_endpoint.post",
        "xpack.idp.sso_endpoint.redirect",
        "xpack.license.self_generated.type",
        "xpack.license.upload.types",
        "xpack.ml.autodetect_process",
        "xpack.ml.datafeed_thread_pool.core",
        "xpack.ml.datafeed_thread_pool.keep_alive",
        "xpack.ml.datafeed_thread_pool.max",
        "xpack.ml.delayed_data_check_freq",
        "xpack.ml.enable_config_migration",
        "xpack.ml.enabled",
        "xpack.ml.inference_model.cache_size",
        "xpack.ml.inference_model.time_to_live",
        "xpack.ml.job_comms_thread_pool.core",
        "xpack.ml.job_comms_thread_pool.keep_alive",
        "xpack.ml.job_comms_thread_pool.max",
        "xpack.ml.max_anomaly_records",
        "xpack.ml.max_inference_processors",
        "xpack.ml.max_lazy_ml_nodes",
        "xpack.ml.max_machine_memory_percent",
        "xpack.ml.max_ml_node_size",
        "xpack.ml.max_model_memory_limit",
        "xpack.ml.max_open_jobs",
        "xpack.ml.min_disk_space_off_heap",
        "xpack.ml.native_inference_comms_thread_pool.core",
        "xpack.ml.native_inference_comms_thread_pool.keep_alive",
        "xpack.ml.native_inference_comms_thread_pool.max",
        "xpack.ml.nightly_maintenance_requests_per_second",
        "xpack.ml.node_concurrent_job_allocations",
        "xpack.ml.persist_results_max_retries",
        "xpack.ml.process_connect_timeout",
        "xpack.ml.use_auto_machine_memory_percent",
        "xpack.ml.utility_thread_pool.core",
        "xpack.ml.utility_thread_pool.keep_alive",
        "xpack.ml.utility_thread_pool.max",
        "xpack.monitoring.collection.ccr.stats.timeout",
        "xpack.monitoring.collection.cluster.stats.timeout",
        "xpack.monitoring.collection.enabled",
        "xpack.monitoring.collection.enrich.stats.timeout",
        "xpack.monitoring.collection.index.recovery.active_only",
        "xpack.monitoring.collection.index.recovery.timeout",
        "xpack.monitoring.collection.index.stats.timeout",
        "xpack.monitoring.collection.indices",
        "xpack.monitoring.collection.interval",
        "xpack.monitoring.collection.ml.job.stats.timeout",
        "xpack.monitoring.collection.node.stats.timeout",
        "xpack.monitoring.elasticsearch.collection.enabled",
        "xpack.monitoring.history.duration",
        "xpack.monitoring.migration.decommission_alerts",
        "xpack.monitoring.templates.enabled",
        "xpack.notification.email.account.domain_allowlist",
        "xpack.notification.email.default_account",
        "xpack.notification.email.html.sanitization.allow",
        "xpack.notification.email.html.sanitization.disallow",
        "xpack.notification.email.html.sanitization.enabled",
        "xpack.notification.jira.default_account",
        "xpack.notification.pagerduty.default_account",
        "xpack.notification.reporting.interval",
        "xpack.notification.reporting.retries",
        "xpack.notification.reporting.warning.enabled",
        "xpack.notification.slack.default_account",
        "xpack.rollup.task_thread_pool.queue_size",
        "xpack.rollup.task_thread_pool.size",
        "xpack.searchable.snapshot.allocate_on_rolling_restart",
        "xpack.searchable.snapshot.cache.range_size",
        "xpack.searchable.snapshot.cache.recovery_range_size",
        "xpack.searchable.snapshot.cache.sync.interval",
        "xpack.searchable.snapshot.cache.sync.max_files",
        "xpack.searchable.snapshot.cache.sync.shutdown_timeout",
        "xpack.searchable.snapshot.shared_cache.decay.interval",
        "xpack.searchable.snapshot.shared_cache.max_freq",
        "xpack.searchable.snapshot.shared_cache.min_time_delta",
        "xpack.searchable.snapshot.shared_cache.range_size",
        "xpack.searchable.snapshot.shared_cache.recovery_range_size",
        "xpack.searchable.snapshot.shared_cache.region_size",
        "xpack.searchable.snapshot.shared_cache.size",
        "xpack.searchable.snapshot.shared_cache.size.max_headroom",
        "xpack.searchable_snapshots.cache_fetch_async_thread_pool.core",
        "xpack.searchable_snapshots.cache_fetch_async_thread_pool.keep_alive",
        "xpack.searchable_snapshots.cache_fetch_async_thread_pool.max",
        "xpack.searchable_snapshots.cache_prewarming_thread_pool.core",
        "xpack.searchable_snapshots.cache_prewarming_thread_pool.keep_alive",
        "xpack.searchable_snapshots.cache_prewarming_thread_pool.max",
        "xpack.security.audit.enabled",
        "xpack.security.audit.logfile.emit_cluster_name",
        "xpack.security.audit.logfile.emit_cluster_uuid",
        "xpack.security.audit.logfile.emit_node_host_address",
        "xpack.security.audit.logfile.emit_node_host_name",
        "xpack.security.audit.logfile.emit_node_id",
        "xpack.security.audit.logfile.emit_node_name",
        "xpack.security.audit.logfile.events.emit_request_body",
        "xpack.security.audit.logfile.events.exclude",
        "xpack.security.audit.logfile.events.include",
        "xpack.security.authc.anonymous.authz_exception",
        "xpack.security.authc.anonymous.roles",
        "xpack.security.authc.anonymous.username",
        "xpack.security.authc.api_key.cache.hash_algo",
        "xpack.security.authc.api_key.cache.max_keys",
        "xpack.security.authc.api_key.cache.ttl",
        "xpack.security.authc.api_key.delete.interval",
        "xpack.security.authc.api_key.delete.timeout",
        "xpack.security.authc.api_key.doc_cache.ttl",
        "xpack.security.authc.api_key.enabled",
        "xpack.security.authc.api_key.hashing.algorithm",
        "xpack.security.authc.jwt.principal_claims",
        "xpack.security.authc.password_hashing.algorithm",
        "xpack.security.authc.realms.file.file1.order",
        "xpack.security.authc.realms.native.native1.order",
        "xpack.security.authc.reserved_realm.enabled",
        "xpack.security.authc.run_as.enabled",
        "xpack.security.authc.service_token.cache.hash_algo",
        "xpack.security.authc.service_token.cache.max_tokens",
        "xpack.security.authc.service_token.cache.ttl",
        "xpack.security.authc.success_cache.enabled",
        "xpack.security.authc.success_cache.expire_after_access",
        "xpack.security.authc.success_cache.size",
        "xpack.security.authc.token.delete.interval",
        "xpack.security.authc.token.delete.timeout",
        "xpack.security.authc.token.enabled",
        "xpack.security.authc.token.thread_pool.queue_size",
        "xpack.security.authc.token.thread_pool.size",
        "xpack.security.authc.token.timeout",
        "xpack.security.authz.store.privileges.cache.max_size",
        "xpack.security.authz.store.privileges.cache.ttl",
        "xpack.security.authz.store.roles.cache.max_size",
        "xpack.security.authz.store.roles.field_permissions.cache.max_size_in_bytes",
        "xpack.security.authz.store.roles.has_privileges.cache.max_size",
        "xpack.security.authz.store.roles.negative_lookup_cache.max_size",
        "xpack.security.authz.timer.indices.enabled",
        "xpack.security.authz.timer.indices.threshold.debug",
        "xpack.security.authz.timer.indices.threshold.info",
        "xpack.security.authz.timer.indices.threshold.warn",
        "xpack.security.autoconfiguration.enabled",
        "xpack.security.automata.cache.enabled",
        "xpack.security.automata.cache.size",
        "xpack.security.automata.cache.ttl",
        "xpack.security.automata.max_determinized_states",
        "xpack.security.crypto.thread_pool.queue_size",
        "xpack.security.crypto.thread_pool.size",
        "xpack.security.dls.bitset.cache.size",
        "xpack.security.dls.bitset.cache.ttl",
        "xpack.security.dls_fls.enabled",
        "xpack.security.enabled",
        "xpack.security.encryption.algorithm",
        "xpack.security.encryption_key.algorithm",
        "xpack.security.encryption_key.length",
        "xpack.security.enrollment.enabled",
        "xpack.security.filter.always_allow_bound_address",
        "xpack.security.fips_mode.enabled",
        "xpack.security.http.filter.allow",
        "xpack.security.http.filter.deny",
        "xpack.security.http.filter.enabled",
        "xpack.security.http.ssl.enabled",
        "xpack.security.operator_privileges.enabled",
        "xpack.security.ssl.diagnose.trust",
        "xpack.security.transport.filter.allow",
        "xpack.security.transport.filter.deny",
        "xpack.security.transport.filter.enabled",
        "xpack.security.transport.ssl.enabled",
        "xpack.security.user",
        "xpack.transform.num_transform_failure_retries",
        "xpack.transform.transform_scheduler_frequency",
        "xpack.watcher.actions.bulk.default_timeout",
        "xpack.watcher.actions.index.default_timeout",
        "xpack.watcher.bulk.actions",
        "xpack.watcher.bulk.concurrent_requests",
        "xpack.watcher.bulk.flush_interval",
        "xpack.watcher.bulk.size",
        "xpack.watcher.enabled",
        "xpack.watcher.encrypt_sensitive_data",
        "xpack.watcher.execution.default_throttle_period",
        "xpack.watcher.execution.scroll.size",
        "xpack.watcher.execution.scroll.timeout",
        "xpack.watcher.index.rest.direct_access",
        "xpack.watcher.input.search.default_timeout",
        "xpack.watcher.internal.ops.bulk.default_timeout",
        "xpack.watcher.internal.ops.index.default_timeout",
        "xpack.watcher.internal.ops.search.default_timeout",
        "xpack.watcher.stop.timeout",
        "xpack.watcher.thread_pool.queue_size",
        "xpack.watcher.thread_pool.size",
        "xpack.watcher.transform.search.default_timeout",
        "xpack.watcher.trigger.schedule.ticker.tick_interval",
        "xpack.watcher.use_ilm_index_management",
        "xpack.watcher.watch.scroll.size",
    ]
    return [key for key in setting_keys if key.startswith(incomplete)]


SETTINGS_VALUE_RE = re.compile(
    (
        r"^((?P<valueStr>.+?):(?P<typeStr>str))|"
        r"((?P<valueFloat>[0-9]+?\.[0-9]+?):(?P<typeFloat>float))|"
        r"((?P<valueInt>[0-9]+?):(?P<typeInt>int))|"
        r"((?P<valueBool>true|1|0|false|yes|no|off|on):(?P<typeBool>bool))|"
        r"(?P<valueNull>.+?):(?P<typeNull>null)$"
    ),
    flags=re.IGNORECASE,
)


class SettingsValue(TypedDict):
    caster: Callable[[str], str | int | float | bool | None]
    value: str


def validate_settings_value(
    value: str | None,
) -> SettingsValue | None:
    # No validation if not provided
    if value is None:
        return None
    match = SETTINGS_VALUE_RE.search(value)
    if match is None:
        raise typer.BadParameter(
            "Invalid settings_value format. "
            "Expected format is <value>:<type> where type is one of str, int, float, bool, null."
        )
    groupdict = match.groupdict()
    type_ = (
        groupdict.get("typeStr")
        or groupdict.get("typeFloat")
        or groupdict.get("typeInt")
        or groupdict.get("typeBool")
        or groupdict.get("typeNull")
        or "str"
    ).lower()
    setting_value = (
        groupdict.get("valueStr")
        or groupdict.get("valueFloat")
        or groupdict.get("valueInt")
        or groupdict.get("valueBool")
        or groupdict.get("valueNull")
        or ""
    )

    caster: Callable[[str], str | int | float | bool | None] = {
        "str": str,
        "int": int,
        "float": float,
        "bool": lambda v: v.lower() in ("true", "1", "yes", "on"),
        "null": lambda _: None,
    }.get(type_, str)
    return {
        "caster": caster,
        "value": setting_value,
    }


def print_settings(
    output: OutputOption, settings: dict[str, Any], result: Result
) -> None:
    if output == "json" or output == "yaml":
        result.print(output)
        return
    # If output is table, csv, tsv, let's make it pretty
    result.value = [
        {
            "key": key,
            "value": value,
            "persistent": ":cross_mark:"
            if key in settings.get("transient", {})
            else ":white_check_mark:",
            "transient": ":white_check_mark:"
            if key in settings.get("transient", {})
            else ":cross_mark:",
            "default": ":cross_mark:"
            if key not in settings.get("defaults", {})
            or value != settings.get("defaults", {})[key]
            else ":white_check_mark:",
        }
        for key, value in settings.get("persistent", {}).items()
        for key, value in settings.get("transient", {}).items()
        for key, value in settings.get("defaults", {}).items()
    ]
    result.print(output)


@app.command()
def settings(
    ctx: typer.Context,
    settings_key: Annotated[
        str | None,
        typer.Argument(
            help="The elasticsearch setting to update.",
            autocompletion=complete_settings_key,
        ),
    ] = None,
    settings_value: Annotated[
        str | None,
        typer.Argument(
            help="The value to set the setting to.",
            callback=validate_settings_value,
        ),
    ] = None,
    transient: Annotated[
        bool,
        typer.Option(
            "--transient",
            help=(
                "If true, the request sets the transient settings. "
                "Defaults to false, which means the request sets the persistent settings."
            ),
        ),
    ] = False,
    with_defaults: Annotated[
        bool,
        typer.Option(
            "--with-defaults/--no-with-defaults", help="Include default settings."
        ),
    ] = False,
    output: OutputOption = "table",
):
    client = Config.from_context(ctx).client
    if settings_key is None and settings_value is None:
        # Get the current settings, without the defaults
        response = client.cluster.get_settings(
            include_defaults=with_defaults, flat_settings=True
        )
        body: dict[str, Any] = response.body
        result: Result = ctx.obj["selector"](response)
        print_settings(output, body, result)
        return

    if settings_value is None:
        raise typer.BadParameter(
            "You must provide a settings_value when settings_key is set."
        )

    params = {settings_key: settings_value["caster"](settings_value["value"])}  # type: ignore
    confirm = Confirm.ask(
        "You are about to change the cluster configuration, are you sure ?",
        default=False,
    )
    if not confirm:
        typer.echo("Operation aborted.")
        raise typer.Abort()
    if transient:
        response = client.cluster.put_settings(transient=params)  # type: ignore
    else:
        response = client.cluster.put_settings(persistent=params)  # type: ignore
    result: Result = ctx.obj["selector"](response)
    print_settings(output, response.body, result)
    return
